{
  "name": "wait.for-es6",
  "version": "0.0.3",
  "description": "Sequential programming for node.js -and the browser-. End of callback hell - Original Wait.for, implemented using upcoming javascript/ES6-Harmony generators",
  "author": {
    "name": "Lucio Tato",
    "email": "luciotato@gmail.com",
    "url": "http://github.com/luciotato"
  },
  "keywords": [
    "fiber",
    "fibers",
    "generator",
    "coroutine",
    "thread",
    "sycn",
    "async",
    "parallel",
    "worker",
    "future",
    "promise",
    "wait",
    "Wait.for",
    "callback hell",
    "piramyd of doom"
  ],
  "homepage": "http://github.com/luciotato/waitfor-ES6",
  "license": "Creative Commons, MIT",
  "bugs": {
    "url": "http://github.com/luciotato/waitfor-ES6/issues"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/luciotato/waitfor-ES6.git"
  },
  "main": "./waitfor.js",
  "engines": {
    "node": ">=0.11.6"
  },
  "scripts": {
    "test": "node --harmony tests",
    "parallel": "node --harmony parallel-tests",
    "demo": "node --harmony waitfor-demo"
  },
  "readme": "Wait.for-ES6\r\n===========\r\n\r\nSequential programming for node.js *and the browser*, end of callback hell.\r\n\r\n***Simple, straightforward abstraction.***\r\n\r\nBy using **wait.for**, you can call any nodejs standard async function in sequential/Sync mode, waiting for result data, \r\nwithout blocking node's event loop.\r\n\r\nDefinitions:\r\n--\r\n* A nodejs standard async function is a function in which the last parameter is a callback: function(err,data)\r\n* A \"fiber\" in this context is a \"generator\" that yields async callable functions.\r\n\r\n\r\n*Advantages:*\r\n<ul>\r\n<li> Avoid callback hell / pyramid of doom\r\n<li> Simpler, sequential programming when required, without blocking node's event loop\r\n<li> Simpler, try-catch exception programming. (default callback handler is: if (err) throw err; else return data)\r\n<li> You can launch multiple parallel non-concurrent fibers.\r\n<li> No multi-threaded debugging nightmares, only one fiber running at a given time.\r\n<li> Can use any node-standard async function with callback(err,data) as last parameter.\r\n<li> Plays along with node programming style. Write your async functions with callback(err,data), but use them in sequential/SYNC mode when required.\r\n<li> Plays along with node cluster. You design for one thread/processor, then scale with cluster on multicores.\r\n</ul>\r\n\r\n- WARNING: Bleeding Edge -\r\n--\r\n\r\nThis is a port of the original [Wait.for] (http://github.com/luciotato/waitfor),\r\nnow implemented using ***the upcoming*** javascript/ES6-Harmony generators.\r\nIt requires ***bleeding edge node v0.11.6, with --harmony command line option***\r\n\r\nThis lib is based on ECMAScript 6 \"Harmony\", the next version of the javascript standard, target release date December 2013.\r\n\r\nThis lib also uses bleeding edge V8 Harmony features, so youâ€™ll need to use the latest (unstable) nodejs version (v0.11.6) and also pass the --harmony flag when executing node.\r\n\r\nExample:\r\n\r\n    cd samples/blogServer\r\n    node --harmony server.js\r\n\r\nWait.for on stable Node\r\n--\r\nIf you want to use ***wait.for*** but you can't use (unstable) node and/or ES6-Harmony\r\nyou can try the<br>\r\n[Wait.for version based on node-fibers] (http://github.com/luciotato/waitfor),\r\nwhich only requires node >= 0.5.2, and the stable package [node-fibers](https://github.com/laverdet/node-fibers)\r\n\r\n\r\nInstall: \r\n-\r\n        npm install wait.for-es6 \r\n\r\nExamples:\r\n-\r\n```javascript\r\n// (inside a generator) call async function fs.readfile(path,enconding), \r\n// wait for result, return data\r\nconsole.log('contents of file: ', yield wait.for(fs.readfile, '/etc/file.txt', 'utf8'));\r\n```\r\n\r\nDNS testing, *using pure node.js* (a little of callback hell):\r\n```javascript\r\nvar dns = require(\"dns\");\r\n    \r\nfunction test(){ \r\n\tdns.resolve4(\"google.com\", function(err, addresses) {\r\n\t\tif (err) throw err;\r\n\t\tfor (var i = 0; i < addresses.length; i++) {\r\n\t\t\tvar a = addresses[i];\r\n\t\t\tdns.reverse(a, function (err, data) {\r\n\t\t\t\tif (err) throw err;\r\n\t\t\t\tconsole.log(\"reverse for \" + a + \": \" + JSON.stringify(data));\r\n\t\t\t});\r\n\t\t};\r\n\t});\r\n}\r\n\r\ntest();\r\n```\r\n***THE SAME CODE***, using **wait.for** (sequential): \r\n```javascript\r\nvar dns = require(\"dns\"), wait=require('wait.for-es6');\r\n\r\nfunction* test(){\r\n\tvar addresses = yield wait.for(dns.resolve4,\"google.com\");\r\n\tfor (var i = 0; i < addresses.length; i++) {\r\n\t\tvar a = addresses[i];\r\n\t\tconsole.log(\"reverse for \" + a + \": \" + JSON.stringify( yield wait.for(dns.reverse,a)));\r\n\t}\r\n}\r\n\r\nwait.launchFiber(test); \r\n```\r\nAlternative, **fancy syntax**, *omiting* **wait.for** (see [The funny thing is...](#the-funny-thing-is))\r\n```javascript\r\nvar dns = require(\"dns\"), wait=require('wait.for-es6');\r\n\r\nfunction* test(){\r\n    var addresses = yield [dns.resolve4, \"google.com\"];\r\n    for( let i=0; i<addresses.length; i++)\r\n        var a=addresses[i];\r\n        console.log(\"reverse for \" + a + \": \" + JSON.stringify( yield [dns.reverse,a] ));\r\n}\r\nwait.launchFiber(test); \r\n```\r\n\r\nDatabase example (pseudocode)\r\n--\r\n*using pure node.js* (a callback hell):\r\n```javascript\r\nvar db = require(\"some-db-abstraction\");\r\n\r\nfunction handleWithdrawal(req,res){  \r\n\ttry {\r\n\t\tvar amount=req.param(\"amount\");\r\n\t\tdb.select(\"* from sessions where session_id=?\",req.param(\"session_id\"),function(err,sessiondata) {\r\n\t\t\tif (err) throw err;\r\n\t\t\tdb.select(\"* from accounts where user_id=?\",sessiondata.user_ID),function(err,accountdata) {\r\n\t\t\t\tif (err) throw err;\r\n\t\t\t\t\tif (accountdata.balance < amount) throw new Error('insufficient funds');\r\n\t\t\t\t\tdb.execute(\"withdrawal(?,?)\",accountdata.ID,req.param(\"amount\"), function(err,data) {\r\n\t\t\t\t\t\tif (err) throw err;\r\n\t\t\t\t\t\tres.write(\"withdrawal OK, amount: \"+ req.param(\"amount\"));\r\n\t\t\t\t\t\tdb.select(\"balance from accounts where account_id=?\", accountdata.ID,function(err,balance) {\r\n\t\t\t\t\t\t\tif (err) throw err;\r\n\t\t\t\t\t\t\tres.end(\"your current balance is \"  + balance.amount);\r\n\t\t\t\t\t\t});\r\n    \t\t\t\t});\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t}\r\n\t\tcatch(err) {\r\n\t\t\tres.end(\"Withdrawal error: \"  + err.message);\r\n\t}\r\n}\r\n```\r\nNote: The above code, although it looks like it will catch the exceptions, **it will not**. \r\nCatching exceptions with callback hell adds a lot of pain, and i'm not sure if you will have the 'res' parameter \r\nto respond to the user. If somebody like to fix this example... be my guest.\r\n\r\n\r\n***THE SAME CODE***, using **wait.for** (sequential logic - sequential programming):\r\n```javascript\r\nvar db = require(\"some-db-abstraction\"), wait=require('wait.for-es6');\r\n\r\nfunction* handleWithdrawal(req,res){  \r\n\ttry {\r\n\t\tvar amount=req.param(\"amount\");\r\n\t\tsessiondata = yield wait.forMethod(db,\"select\",\"* from session where session_id=?\",req.param(\"session_id\"));\r\n\t\taccountdata = yield wait.forMethod(db,\"select\",\"* from accounts where user_id=?\",sessiondata.user_ID);\r\n\t\tif (accountdata.balance < amount) throw new Error('insufficient funds');\r\n\t\tyield wait.forMethod(db,\"execute\",\"withdrawal(?,?)\",accountdata.ID,req.param(\"amount\"));\r\n\t\tres.write(\"withdrawal OK, amount: \"+ req.param(\"amount\"));\r\n\t\tbalance = yield wait.forMethod(db,\"select\",\"balance from accounts where account_id=?\", accountdata.ID);\r\n\t\tres.end(\"your current balance is \"  + balance.amount);\r\n\t\t}\r\n\tcatch(err) {\r\n\t\tres.end(\"Withdrawal error: \"  + err.message);\r\n}  \r\n```\r\n\r\nNote: Exceptions will be catched as expected. \r\ndb methods (db.select, db.execute) will be called with this=db \r\n\r\nMore examples:\r\n\r\n* see  [blogServer] (http://github.com/luciotato/waitfor-ES6/tree/master/samples/blogServer) \r\n* see  [ajaxServer] (http://github.com/luciotato/waitfor-ES6/tree/master/samples/ajaxServer) \r\n\r\nUsage: \r\n-\r\n```javascript\r\nvar wait=require('wait.for-es6');\r\n\r\n// launch a new fiber \r\nwait.launchFiber(my_seq_function, arg,arg,...)\r\n\r\n// fiber (generator)\r\nfunction* my_seq_function(arg,arg...){\r\n    // call async_function(arg1), wait for result, return data\r\n    var myObj = yield wait.for(async_function, arg1); \r\n    // call myObj.querydata(arg1,arg2), wait for result, return data\r\n    var myObjData = yield wait.forMethod(myObj,'queryData', arg1, arg2);\r\n    console.log(myObjData.toString());\r\n\r\n    // call async function fs.readfile(path,enconding), wait for result, return data\r\n    console.log('contents of file: ' yield [ fs.readfile, path, enconding ]);\r\n}\r\n\r\n// fiber (generator)\r\nfunction* handler(req,res){\r\n    res.end ( markdown ( yield [ fs.readfile, 'post-'+req.query.postnum, 'utf8' ] );\r\n}\r\n```\r\n\r\n\r\nThe funny thing is...\r\n--\r\nAfter uploading the original **wait.for** based on node-fibers, several people ask me: \"why not base it on ES6-Harmony generators?\". So I started looking for information on such a migration. \r\nAfter a quick search, the migration did not seem possible:\r\n(According to this: http://stackoverflow.com/questions/18293563/can-node-fibers-be-implemented-using-es6-generators\r\nand this: http://calculist.org/blog/2011/12/14/why-coroutines-wont-work-on-the-web)\r\n\r\nHowever, the basic building blocks of ES6 generators are the same for the concept of fibers, \r\nso I started trying to port **wait.for** to ES6...\r\n\r\nIt didn't looked good, ***but it went much better than expected!***\r\n\r\nThe funny thing is, the implementation of the core function ***wait.for(async,arg...)***, using ES6 generators is:\r\n\r\n```javascript\r\nwait.for = function( asyncFn ) { return arguments; }\r\n```\r\nYes, just return arguments.\r\n\r\nCompare it to **wait.for** based on node-fibers:\r\n\r\n```javascript\r\nwait.for = function(asyncFn){ \r\n        var newargs=Array.prototype.slice.call(arguments,1); // remove function from args\r\n        return Wait.applyAndWait(null,fn,newargs); \r\n    }\r\n```\r\n\r\n**wait.for** based on node-fibers *actually does something*: calls ***Wait.applyAndWait*** \r\n\r\nIn contrast ES6 based implementation of **wait.for(asyncFn)** does basically nothing (the magic control flow resides in *yield*)\r\n\r\nYou use ***wait.for*** inside a generator (function*) in conjunction with new JS/ES6 ***yield*** keyword, as in:\r\n\r\n```javascript\r\nvar data = yield wait.for ( fs.readFile, '/etc/somefile' );\r\n```\r\n\r\n<h3>Surprisingly, ES6 generators-based implementation of <i>function wait.for(asyncFn)</i> \r\nis almost a no-op, you can even omit it...</h3></blockquote>\r\n\r\nGiven that evaluating ***wait.for*** return its arguments, the call can be replaced with an object literal, which is an array-like object. It results that:\r\n```javascript\r\n\r\nwait.for( asyncFn, arg1, arg2 )  // return arguments\r\n=== {0:asyncFn, 1:arg1, 2:arg2 } // is equivalent to...\r\n~= [ asyncFn, arg1, arg2 ] // is similar to...\r\n```\r\nso, the following two snippets are equivalent (inside a generator launched via ***wait.launchFiber(generator)***):\r\n\r\n```javascript\r\n// call an async function and wait for results, (wait.for syntax):\r\nconsole.log( yield wait.for ( fs.readFile, '/etc/somefile', 'utf8' ) );\r\n\r\n// call an async function and wait for results, (fancy syntax):\r\nconsole.log( yield [ fs.readFile, '/etc/passwd', 'utf8' ] );\r\n```\r\n\r\n\r\nRoadmap\r\n--\r\n\r\n * Parallel execution, launch one fiber for each array item, waits until all fibers complete execution.\r\n   * **function parallel.map(arr,fn,callback)** return transformed array;\r\n   * **function parallel.filter(arr,fn,callback)** return filtered array;\r\n   * Status: *BETA* in complementary lib [parallel.js](http://github.com/luciotato/parallel-ES6)\r\n",
  "readmeFilename": "README.md",
  "_id": "wait.for-es6@0.0.3",
  "dist": {
    "shasum": "9982193a9be92e60be250a337fdab9475d51a80f"
  },
  "_from": "wait.for-es6@",
  "_resolved": "https://registry.npmjs.org/wait.for-es6/-/wait.for-es6-0.0.3.tgz"
}
